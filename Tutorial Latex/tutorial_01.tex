\documentclass{acmart}
\title{Benchmarking sorting algorithms in Python}
\subtitle{INF221 Term Paper, NMBU, Autumn 2019}

\author{Bishnu Poudel}
\email{bishnu.poudel@nmbu.no}
\affiliation{} 

\author{Mohamed Radwan}
\email{mohamed.radwan@nmbu.no}

\begin{document}
\maketitle




In this paper, we generate the runtimes for three pure sorting algorithms that follow the divide-and-conquer approach. In addition, we benchmark the inbuilt numpy sort function- np.sort() and also the python sort function - sorted(). 
Then we compare these real-life runtimes with the theoritical runtimes that we have learnt as a part of the Algorithms 
and data structure course at NMBU. We also analyse and plot the distributions of runtimes we foundData is collected for list sizes  from 10 to 10 million in order to study the asymtotic behavior of these algorithms.
The work has been done using python and its libraries.




Sorting and searching are basic and routine operations for computers of any type. Much research has already been done in the subject, and computers today use the most robust algorithms possible that meet their specific requirement/application. Many applications use a blend of 2 or more algorithms depending on the nature input data or the application.  However, it would be interesting to see how the  sorting algorithms behave stand-alone  in real life.

In the following section, we are benchmarking sorting algorithms in python based on their runtimes. This paper is also the final 
term-paper for the 'Computer Science for Data Scientists'  course at NMBU. Here, we get to compare the theoritical runtimes of sorting algorithms  to their real-life runtimes.

The main questions we are trying to address are: Do the algorithms show their theoritical average case behavior in real situations? 
Which of the stand alone sort is more efficient? Do these standalone sorts have a chance against the built-in sorts of numpy and python?
How are the runtimes of each run distributed, is there any statistical significance in the distribution?

In the Theory section, we describe the psuedo-code of the algorithms together with their theoritical runtimes. We discuss the best, average and the worst cases.  In the Methods section, we describe the python implementation of the algorithms, together with the python functions  we 
wrote to extract the runtime information. We also discuss the type and amount of data we collected. Results section has facts and figures from 
our analysis. In the Discussion section, we summarize our findings and compare them to the theoritical expectations. We also compare the 
standalone algorithms with the pre-implemented algorithms in numpy and python. Acknowledgements and References conclude the paper.




\end{document}
